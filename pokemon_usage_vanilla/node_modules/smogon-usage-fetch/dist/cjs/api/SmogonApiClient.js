"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _config;
Object.defineProperty(exports, "__esModule", { value: true });
exports.SmogonApiClient = void 0;
const lodash_1 = require("lodash");
const chaos_1 = require("../parsing/chaos");
const SmogonUrlBuilder_1 = require("./SmogonUrlBuilder");
const formats_1 = require("../parsing/html/formats");
const leads_1 = require("../parsing/leads");
const metagame_1 = require("../parsing/metagame");
const timeframes_1 = require("../parsing/html/timeframes");
const usages_1 = require("../parsing/usages");
const axios_1 = __importDefault(require("axios"));
/**
 * API client to load data from Smogon API.
 *
 * @public
 */
class SmogonApiClient {
    /**
     * Creates a new instance.
     *
     * @param config Client config. See {@link SmogonApiClientConfig}.
     */
    constructor(config = {}) {
        _config.set(this, void 0);
        __classPrivateFieldSet(this, _config, lodash_1.defaults(config, {
            baseUrl: SmogonApiClient.API_BASE_URL,
        }));
    }
    /**
     * Loads a list of all available timeframes.
     *
     * @public
     * @return List of timeframe names.
     */
    async fetchTimeframes() {
        const url = this.createUrlBuilder().build();
        return timeframes_1.parseTimeframesPage(await this.request(url, "txt" /* TEXT */));
    }
    /**
     * Loads a list of all available formats for a given timeframe.
     *
     * @public
     * @param timeframe Timeframe to load.
     * @param useMonotype If monotype formats should be loaded instead of "normal" formats, defaults to false.
     * @return List of formats.
     */
    async fetchFormats(timeframe, useMonotype = false) {
        const urlBuilder = this.createUrlBuilder();
        urlBuilder.setTimeframe(timeframe);
        if (useMonotype) {
            urlBuilder.setSubPath("monotype" /* MONOTYPE */);
        }
        const url = urlBuilder.build();
        return formats_1.parseFormatsPage(await this.request(url, "txt" /* TEXT */));
    }
    /**
     * Loads usage data for the given timeframe and format.
     *
     * @public
     * @param timeframe Timeframe to load.
     * @param format Format to load.
     * @return Usages data.
     */
    async fetchUsages(timeframe, format) {
        const url = this.createUrlBuilder()
            .setFileType("txt" /* TEXT */)
            .setTimeframe(timeframe)
            .setFormat(format)
            .build();
        return usages_1.usageFromString(await this.request(url, "txt" /* TEXT */));
    }
    /**
     * Loads lead data for the given timeframe and format.
     *
     * @public
     * @param timeframe Timeframe to load.
     * @param format Format to load.
     * @return Leads data.
     */
    async fetchLeads(timeframe, format) {
        const url = this.createUrlBuilder()
            .setSubPath("leads" /* LEADS */)
            .setFileType("txt" /* TEXT */)
            .setTimeframe(timeframe)
            .setFormat(format)
            .build();
        return leads_1.leadsFromString(await this.request(url, "txt" /* TEXT */));
    }
    /**
     * Loads metagame data for the given timeframe and format.
     *
     * @public
     * @param timeframe Timeframe to load.
     * @param format Format to load.
     * @return Metagame data.
     */
    async fetchMetagame(timeframe, format) {
        const url = this.createUrlBuilder()
            .setSubPath("metagame" /* METAGAME */)
            .setFileType("txt" /* TEXT */)
            .setTimeframe(timeframe)
            .setFormat(format)
            .build();
        return metagame_1.metagameFromString(await this.request(url, "txt" /* TEXT */));
    }
    /**
     * Loads moveset data for the given timeframe and format.
     *
     * Note: The `/chaos/` and the `/moveset/` endpoints are identical in terms of data.
     * Previously this method aliased to `fetchChaos` which was removed for consistency.
     *
     * @public
     * @param timeframe Timeframe to load.
     * @param format Format to load.
     * @return Moveset data.
     */
    async fetchMovesets(timeframe, format) {
        const url = this.createUrlBuilder()
            .setSubPath("chaos" /* CHAOS */)
            .setFileType("json" /* JSON */)
            .setTimeframe(timeframe)
            .setFormat(format)
            .build();
        return chaos_1.mapChaosData(await this.request(url, "json" /* JSON */));
    }
    createUrlBuilder() {
        return new SmogonUrlBuilder_1.SmogonUrlBuilder(__classPrivateFieldGet(this, _config).baseUrl);
    }
    async request(url, responseType) {
        const requestConfig = {
            timeout: 10000,
        };
        if (responseType == "json" /* JSON */) {
            requestConfig.responseType = "json";
        }
        else if (responseType === "txt" /* TEXT */) {
            requestConfig.responseType = "text";
        }
        const response = await axios_1.default.get(url.toString(), requestConfig);
        return response.data;
    }
}
exports.SmogonApiClient = SmogonApiClient;
_config = new WeakMap();
SmogonApiClient.API_BASE_URL = new URL("https://www.smogon.com/stats/");
//# sourceMappingURL=SmogonApiClient.js.map