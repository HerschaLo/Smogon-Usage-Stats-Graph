var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var _config;
import { defaults } from "lodash";
import { mapChaosData } from "../parsing/chaos";
import { SmogonUrlBuilder } from "./SmogonUrlBuilder";
import { parseFormatsPage } from "../parsing/html/formats";
import { leadsFromString } from "../parsing/leads";
import { metagameFromString } from "../parsing/metagame";
import { parseTimeframesPage } from "../parsing/html/timeframes";
import { usageFromString } from "../parsing/usages";
import axios from "axios";
/**
 * API client to load data from Smogon API.
 *
 * @public
 */
class SmogonApiClient {
    /**
     * Creates a new instance.
     *
     * @param config Client config. See {@link SmogonApiClientConfig}.
     */
    constructor(config = {}) {
        _config.set(this, void 0);
        __classPrivateFieldSet(this, _config, defaults(config, {
            baseUrl: SmogonApiClient.API_BASE_URL,
        }));
    }
    /**
     * Loads a list of all available timeframes.
     *
     * @public
     * @return List of timeframe names.
     */
    async fetchTimeframes() {
        const url = this.createUrlBuilder().build();
        return parseTimeframesPage(await this.request(url, "txt" /* TEXT */));
    }
    /**
     * Loads a list of all available formats for a given timeframe.
     *
     * @public
     * @param timeframe Timeframe to load.
     * @param useMonotype If monotype formats should be loaded instead of "normal" formats, defaults to false.
     * @return List of formats.
     */
    async fetchFormats(timeframe, useMonotype = false) {
        const urlBuilder = this.createUrlBuilder();
        urlBuilder.setTimeframe(timeframe);
        if (useMonotype) {
            urlBuilder.setSubPath("monotype" /* MONOTYPE */);
        }
        const url = urlBuilder.build();
        return parseFormatsPage(await this.request(url, "txt" /* TEXT */));
    }
    /**
     * Loads usage data for the given timeframe and format.
     *
     * @public
     * @param timeframe Timeframe to load.
     * @param format Format to load.
     * @return Usages data.
     */
    async fetchUsages(timeframe, format) {
        const url = this.createUrlBuilder()
            .setFileType("txt" /* TEXT */)
            .setTimeframe(timeframe)
            .setFormat(format)
            .build();
        return usageFromString(await this.request(url, "txt" /* TEXT */));
    }
    /**
     * Loads lead data for the given timeframe and format.
     *
     * @public
     * @param timeframe Timeframe to load.
     * @param format Format to load.
     * @return Leads data.
     */
    async fetchLeads(timeframe, format) {
        const url = this.createUrlBuilder()
            .setSubPath("leads" /* LEADS */)
            .setFileType("txt" /* TEXT */)
            .setTimeframe(timeframe)
            .setFormat(format)
            .build();
        return leadsFromString(await this.request(url, "txt" /* TEXT */));
    }
    /**
     * Loads metagame data for the given timeframe and format.
     *
     * @public
     * @param timeframe Timeframe to load.
     * @param format Format to load.
     * @return Metagame data.
     */
    async fetchMetagame(timeframe, format) {
        const url = this.createUrlBuilder()
            .setSubPath("metagame" /* METAGAME */)
            .setFileType("txt" /* TEXT */)
            .setTimeframe(timeframe)
            .setFormat(format)
            .build();
        return metagameFromString(await this.request(url, "txt" /* TEXT */));
    }
    /**
     * Loads moveset data for the given timeframe and format.
     *
     * Note: The `/chaos/` and the `/moveset/` endpoints are identical in terms of data.
     * Previously this method aliased to `fetchChaos` which was removed for consistency.
     *
     * @public
     * @param timeframe Timeframe to load.
     * @param format Format to load.
     * @return Moveset data.
     */
    async fetchMovesets(timeframe, format) {
        const url = this.createUrlBuilder()
            .setSubPath("chaos" /* CHAOS */)
            .setFileType("json" /* JSON */)
            .setTimeframe(timeframe)
            .setFormat(format)
            .build();
        return mapChaosData(await this.request(url, "json" /* JSON */));
    }
    createUrlBuilder() {
        return new SmogonUrlBuilder(__classPrivateFieldGet(this, _config).baseUrl);
    }
    async request(url, responseType) {
        const requestConfig = {
            timeout: 10000,
        };
        if (responseType == "json" /* JSON */) {
            requestConfig.responseType = "json";
        }
        else if (responseType === "txt" /* TEXT */) {
            requestConfig.responseType = "text";
        }
        const response = await axios.get(url.toString(), requestConfig);
        return response.data;
    }
}
_config = new WeakMap();
SmogonApiClient.API_BASE_URL = new URL("https://www.smogon.com/stats/");
export { SmogonApiClient };
//# sourceMappingURL=SmogonApiClient.js.map